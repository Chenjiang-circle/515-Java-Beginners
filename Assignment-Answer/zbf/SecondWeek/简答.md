# 1. 简述字符串池的作⽤和⼯作原理
### 作用：提升性能和减少内存开销，避免字符串的重复创建
### 工作原理：1.采用字面值的方式创建一个字符串时，JVM首先会去字符串池中查找是否存在这个对象，如果不存在，则在字符串池中创建这个对象，然后将池中这个对象的引用地址返回给字符串常量，这样字符串常量会指向池中这个字符串对象；如果存在，则不创建任何对象，直接将池中这个对象的地址返回，赋给字符串常量。
### 2.采用new关键字新建一个字符串对象时，JVM首先在字符串池中查找有没有这个字符串对象，如果有，则不在池中再去创建这个对象了，直接在堆中创建一个字符串对象，然后将堆中的这个对象的地址返回赋给引用字符串常量，这样，这个字符串常量就指向了堆中创建的这个字符串对象；如果没有，则首先在字符串池中创建一个字符串对象，然后再在堆中创建一个字符串对象，然后将堆中这个字符串对象的地址返回赋给字符串常量引用，这样，字符串常量指向了堆中创建的这个字符串对象。
# 2.ArrayList、LinkedList、Vector三种集合的区别
## 一、同步性

### arraylist,linkedlist是不同步的，而vestor是的。所以如果要求线程安全的话，可以使用arraylist或linkedlist，可以节省为同步而耗费开销。但在多线程的情况下，有时候就不得不使用vector了。当然，也可以通过一些办法包装arraylist,linkedlist，使他们也达到同步，但效率可能会有所降低。

## 二、数据增长
### 从内部实现机制来讲arraylist和vector都是使用objec的数组形式来存储的。当你向这两种类型中增加元素的时候，如果元素的数目超出了内部数组目前的长度它们都需要扩展内部数组的长度，vector缺省情况下自动增长原来一倍的数组长度，arraylist是原来的50%,所以最后你获得的这个集合所占的空间总是比你实际需要的要大。所以如果你要在集合中保存大量的数据那么使用vector有一些优势，因为你可以通过设置集合的初始化大小来避免不必要的资源开销。

## 三、检索、插入、删除对象的效率

### arraylist和vector中，从指定的位置（用index）检索一个对象，或在集合的末尾插入、删除一个对象的时间是一样的，可表示为o(1)。但是，如果在集合的其他位置增加或移除元素那么花费的时间会呈线形增长：o(n-i)，其中n代表集合中元素的个数，i代表元素增加或移除元素的索引位置。为什么会这样呢？以为在进行上述操作的时候集合中第i和第i个元素之后的所有元素都要执行(n-i)个对象的位移操作。
### linkedlist中，在插入、删除集合中任何位置的元素所花费的时间都是一样的—o(1)，但它在索引一个元素的时候比较慢，为o(i),其中i是索引的位置。

### 所以，如果只是查找特定位置的元素或只在集合的末端增加、移除元素，那么使用vector或arraylist都可以。如果是对其它指定位置的插入、删除操作，最好选择linkedlist